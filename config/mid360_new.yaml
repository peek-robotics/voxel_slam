General:
  lid_topic:  "/lidar_3d/livox/lidar"
  imu_topic:  "/lidar_3d/livox/imu"
  odom_link: "map"
  base_link: "livox_frame"
  odom_pub_topic: "/odometry/lio"
  send_tf: false
  previous_map: ""
  bagname: ""
  lidar_type: 6 # 0: Livox, 1: Velodyne, 2: Ouster, 3: Hesai, 4: Robosense, 5: Tartanair, 6: Livox (PC2 format), 7: Generic PC2 XYZI
  blind: 0.5 # 0.5
  point_filter_num: 3
  extrinsic_tran: [-0.011, -0.02329, 0.04412]
  extrinsic_rota: [1, 0, 0,
                   0, 1, 0,
                   0, 0, 1]
  is_save_map: 0
  imu_flip_z: false
  acc_scale: 9.81
  enable_loop_closure: false # If you only want odometry, set this to false
  use_odom_init_tf: true # Initialize lidar odometry from current odom frame (only useful when we are not publishing tf)

LocalAccumulated:
  # Publishes the last N frames accumulated and transformed to the current frame
  # useful for stuff that requires higher point density i.e. segmentation if you have a low density lidar (e.g. 16 beam, mid360)
  pub_local_accumulated: true 
  # Number of frames to accumulate
  rolling_buffer_size: 10
  # Crop box to limit the size of the accumulated cloud
  cropbox_min_x: -2.0
  cropbox_min_y: -8.0
  cropbox_min_z: -1.0
  cropbox_max_x: 15.0
  cropbox_max_y: 8.0
  cropbox_max_z: 2.0

WheelOdom:
  # Wheel-odometry sanity check (watchdog). I found this useful to  prefent huge runaway drift when the lio gets lost in featureless areas.
  # Compares lio odom forward velocity (body x) vs wheel odom linear.x. You could use any other odometry source here as well.
  # If mismatch persists for `violation_frames`, triggers a lio odom reset.
  enable: false
  # Topic publishing nav_msgs/Odometry from the wheel/robot base.
  topic: "/odometry/wheel"
  # Allowed relative mismatch as a fraction of |wheel_vx|.
  # Tolerance is: max(|wheel_vx| * tolerance_ratio, min_tolerance).
  tolerance_ratio: 0.5
  # Minimum absolute tolerance (m/s) to prevent false triggers near zero speed.
  min_tolerance: 0.5
  # Number of consecutive violating checks required to trigger a reset.
  violation_frames: 10
  # If wheel odom data is older than this (seconds), the check is skipped.
  timeout: 0.2

Odometry:
  max_init: 30
  cov_gyr: 0.1
  cov_acc: 1
  rdw_gyr: 0.0001
  rdw_acc: 0.0001
  # indoor:0.1, outdoor:0.25, high altitude: 0.5
  down_size: 0.075
  dept_err: 0.02
  beam_err: 0.05
  # indoor: 0.5-1, high speed: 2, high altitude: 4
  voxel_size: 0.5
  min_eigen_value: 0.0025
  # The number of degenrate scans to make the system reset
  degrade_bound: 20
  point_notime: 0

LocalBA:
  win_size: 10
  max_layer: 2
  cov_gyr: 0.01
  cov_acc: 2
  rdw_gyr: 0.0001
  rdw_acc: 0.0001
  min_ba_point: 1
  plane_eigen_value_thre: [6.0, 6.0, 6.0, 6.0]
  imu_coef: 0.0002
  thread_num: 5

Loop:
  # The criterion for loop closure
  # It can be adjusted according to the environment
  jud_default: 0.5 # 0.22 0.34
  # The criterion for ICP to ensure the success of two scans matching
  icp_eigval: 10 # 8
  # The threshold for the ratio of drift and travelling distance
  ratio_drift: 0.01
  curr_halt: 10
  prev_halt: 10
  # In previous map, accumulate acsize scans to generate BTC descriptor
  acsize: 10
  mgsize: 5
  # The parameters of BTC in normal and high altitude environment are differernt
  isHighFly: 0

GBA:
  voxel_size: 2
  min_eigen_value: 0.01
  eigen_value_array: [4.0, 4.0, 4.0, 4.0]
  total_max_iter: 6
